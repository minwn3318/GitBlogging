# 스프링 데이터베이스
영속석 : 파일 시스템, 관계형 데이터베이스 등을 통해 구현할 수 있다
영속성은 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성

spring database connectivity
- 자바의 기본 데이터 베이스 프로그래밍 방법이다
- 규격에 따라 정의된 인터페이스들을 구현한 driver 클래스를 사용해 서로 다른 데이터베이스를 동일한 방법으로 사용할 수 있는 구조를 제공한다
- 아래 서술할 다른 모든 방법도 내부적으로 jdbc를 사용한다
- 별도 추가 라이브러리 설치 없이도 사용할 수 있기에 호환성이 가장 좋지만, db마다 다른 sql 구문을 지원하거나 트랜잭션이나 성능에 대해서는 개발자가 직접 구현해야하는 부분이 많다

Connection connection = DriverManager.getConnection(url, username, password);

sql 중심 기술
mybatis와 spring은 대표적인 sql 중심 기술이다
데이터베이스에 접근하기 위해 sql 쿼리문을 애플리케이션 내부에 직접적으로 작성하는 것이 중심이 된다

mybatis
xml 또는 어노테이션을 사용하여 sql 쿼리를 매핑하고 실행할 수 있도록 지원한다
자동으로 connection 관리를 해주며 사용할 때의 중복 작업 대부분을 없애준다

복잡한 쿼리나 다이나미하게 변경되는 쿼리 작성이 쉽다
관심사 부니를 통해 유지보수성을 높일 수 잇다

template
코어 패키지의 중앙 클래스로의 사용을 단순화하고 일반적인오류를 방지하는데 도움이 된다, 개발자가 기술을 쉽게 사용할 수 있도록 도와주는 클래스로 순수 sql만을 사용하는 것에 비해 편히라고 코드를 단축시킬 수 있다

객체 중심 기술
- 데이터를 객체 관점으로 바라보는 기술
- sql 쿼리문을 직접적으로 작성하기 보다는 자바 객체를 이용해 애플리케이션 내부에서 객체를 sql 쿼리문으로 자동 변환환 후에 데이터베이스 테이블에 접근한다

jap
자바에서 orm을 사용하기 위한 표준 인터페이스를 모아둔것이다
jpa를 사용하기 위해 jpa를 구현한 orm framwork를 사용해야한다
jpa의 대표적인 구현체로는 hibernate, eclipseLink 등이 있다

ORM이란?
객체지향 프로그래밍은 클래스를 사용하고 관계형 데이터베이스는 테이블을 사용한다
하지만 객체 모델과 관계형 모델 간에는 패러다임의 불일치가 존재하게 된다

상속성
일치
연관성 표현 방식의 차이
데이터 접근 방법의 차이

orm이란 객체와 관계형 데이터베이스를 연결할 계층의 역할로 제시된 패러다임
- orm은 객체 간의 관계를 바탕으로 sql을 자동으로 생성하여 이러한 불일치를 해결해준다
- 즉, 객체를 통해 간접적으로 데이터 베이스를 다룰 수 있게 된다
- rdm의 model을 oop의 entity 형태로 투영시키는 방식을 사용한다
- orm은 엔티티와 테이블을 자동으로 매핑 해준다

orm 장점
- 객체지향적으로 데이터를 관리할 수 있기 때문에 프로그램의 전체 구조를 일관되게 유지할 수 있다
- 로직을 쿼리에 집중하기 보다는 객체 자체에 집중할 수 있다
- sql 쿼리를 직접 작성하는 것이 아닌 객체지향 프로그래밍 언어의 문법과 메소드를 활용하므로 코드의 가독성이 높다
- 데이터베이스에 대한 종속성을 줄일 수 있다
-> 객체 가느이 관계를 바탕으로 sql문을 자동으로 생성하고 객체의 자료형 타입까지 사용할 수 있기 때문에 rdbms의 데이터 구조와 객체 지향 모델 사이의 간격을 좁힐 수 있다

orm 단점
- 학습 곡선이 높고 진입 장벽이 높다
- orm으로 모든 쿼리를 대체할 수 없으므로 jpql, querydsl등의 기술도 사용할 수 있어야 한다
- 복잡한 query 작성시, orm 사용에 대한 난이도가 급격히 증가한ㄷ
- 호출 방식에 따라 성능이 천차만별이며, 잘못 구현된 경우 속도 ㅈ저하 및 일관성이 무너지는 문제넘이 발생할 수 있다

jpa
jap는 자바 애플리케이션에서 관계형 데이터베이스를 객체 관계방식으로 사용할 수 있도록 만든 인터페이스이다

jpa
- jpa는 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스와 어노테이션의 표준 집합을 정의한다
- jpa는 단순한 명세이기에 구현은 없고, 다양한 orm 프레임워크에서 구현할 수 있는 공통 api를 제공한다
- hibernate는 jpa의 구현체로 jpa의 모든 기능을 지원하며, 객체와 관계형 데이터베이스 간의 매핑을 자동으로 처리하여 개발자가 일일이 sql 쿼리를 작성하지 않도록 도아준다
(의존성 낮추고, 다중상속, 구현체를 바꾸기 위해, 확장성을 위해)

jpa 사용 이유
- 생산성
메서드 호출만으로 쿼리를 수행할 수 있다
- 유지보수
테이블 칼럼 변경 시 이전에는 sql을 모두 확인한 후 변경된 값들을 모두 확인해 수정해야 했다
jpa는 이러한 작업들을 개발자 대신 수행하므로 유지보수 측면에서 장점이 잇다
- 패러다임 불일치 해결
객체 모델과 관계형 모델간에는 패러다임의 불일치 문제가 발생한다
패러다임 불이치 문제를 해결해준다
- 데이터 접근 추상화와 벤더 독힙성
여러 db벤더마다 다른 sql을 사용하기 때문에 어플리케이션이 처음 선택한 데이터베이스 기술에 종속되는 문제가 발생한다 jpa는 애플리케이션과 데이터베이스 사이에 추상화 된 데이터 접근 계층을 제공해 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다

- 표준
jpa는 자바 진영의 orm 표준 기술로 표준을 사용하면 다른 구현기술로 손쉽게 변경할 수 이다

영속성 컨텍스트
- 영속성 컨텍스트는 엔티티를 영구 저장하는 환경이라는 뜻이다
영속성 컨텍스트는 애플리케이션과 디비 사이에서 객체를 보관하는 가상의 디비 역할을 한다
- 엔티티 -> 디비 테이블에 대응하는 하나의 클래스로 디비에서 영속적으로 저장된 데이터를 자바 객체로 매핑해 인스턴스 형태로 존재하는 데이터를 말한다
- 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티르 보관하고 관리하게 된다. 영속성 컨텍스트에는내부에 캐시를 갖는다 이를 1차 캐시라고 한다. 1차 캐시는 아이디를 키, 값을 엔티티로 하는 맵 형시그올 되어 있다 만약 엔티티를 조회했을 때 1 차 캐시에 엔티티가 존재한다면 디비를 찾아보지 않아도 된다
(한번 찾아본 테이블은 1차 캐시에 저장되어 있다)

쓰기 지연 sql 저장소
- 한 트랜잭션 안에서 이루어지는 쿼리를 쓰기 지연 에스큐엘 저장소에 저장해 갖고 있다가 트랜잭션이 커밋되느 순간 한번에 쿼리를 디비에 날리는 것을 말한다
- 디비 커넥션 시간을 줄일 수 있고 한 틀내잭션이 테이블에 접근하는 시간을 줄일 수 있다는 장점이 있따

엔티티 생명주기
- 비영속 : 객체 생성 후 영속성 컨텍스트와 관계가 없는 상태
- 영속 : 객체 생성후 em.persist(entity)를 호출하여 영속성 컨텍스트에 들어간 상태
- 준영속 : ㅕㅇ속성 컨텍스트에 저장되었다가 분리되어 나온 상태
- 삭제 : 객체를 삭제한 상태를 의미한다

jpql 쿼리 실행
- jpgl 쿼리를 실행하면 sql로 변환하며 디비에 쿼리를 직접 보낸다. 이때 1차 캐시에만 저장되고 디베이 저장되지 않은 데이터가 있는경우, 원하는 결과를 얻지 못할 우려가 있으므로 jpql 쿼리 시점에 자동으로 em.flush가 호출된다

## 영속성 컨텍스트의 장점
- 1차 캐시
만약 엔티티를 조회했을 경우 1차 캐시에 엔티티가 존재한다면 디비에 셀럭터 구문을 보내지 않아도 된다
즉 말 그대로 캐시로써의 기능과 장점을갖고 있다

- 쓰기 지연
엔티티 저장 시 바로 디비에 인설트 쿼리를 보내느 것이 아니라 영속성 컨텍스트의 쓰기 지연 저장소에 인설트 쿼리를저장하고, 1차 캐시에 엔티티를 저장한다
쓰기 지연 sql 저장소에 있는 쿼리들을 플러시 작업이 될 때 한 번에 보내게 된다
-> 디비 커넥션 시간을 줄일 수 있고 한 트랜잭션이 테이블에 접근하느 ㄴ시간을 줄일 수 잇다

- 변경 감지
영속성 컨텍스트 1차 캐시에는 스냅샷 컬럼이 존재한다
- 1차 캐시 저장 순간의 데이터를 스냅샷에 기록하고 flush 시점에 스냅샷의 엔티티와 현재 엔티티의 상태를 비교하여 변경된 부분이 있으면 자졷으올 update 쿼리를 디비에 보낸다

- 지연로딩
지연로딩은 연관 관계매핑되어 있는 에티티를 조회 시 우선 프로깃 객체를 반환하고 실제로 필요할 때 쿼리를 날려 가져오는 기능이다
